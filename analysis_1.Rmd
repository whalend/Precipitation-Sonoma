---
title: "Sonoma precipitation data analysis1"
author: "whalen"
date: "November 18, 2014"
output: html_document
---

Outliers have been replaced with `NA` (see `explore_report.Rmd` for details). Here I load the datasets with the `NA`s inserted and start setting things up for analyses - thin plate spline and/or regression kriging.

Load libraries I plan to use for data manipulation (`dplyr`) and plotting (`ggplot2`).
```{r load basic libraries, echo=TRUE}
suppressPackageStartupMessages(library(ggplot2))
suppressPackageStartupMessages(library(plyr))
suppressPackageStartupMessages(library(dplyr))
```

Read-in the data sets, one daily and one hourly, and then plot. For outlier replacement I settled on a daily precipitation threshold of greater than or equal to 6 inches, and an hourly precipitation threshold of greater than or equal to 1 inch.
```{r read in daily data, echo=TRUE}
dy_rg_data <- readRDS("dy_rg_data.rds")
summary(dy_rg_data)
dy_rg_data$id <- as.factor(dy_rg_data$id)# change `id` from character to factor
qplot(id, daily_ppt, data=dy_rg_data) + theme_bw()
```

Replace ppt values >= 6 with `NA`
```{r outliers to NA}
dy_rg_data$daily_ppt[dy_rg_data$daily_ppt>=6] <- NA

qplot(as.numeric(year), daily_ppt, data = dy_rg_data %>% 
            group_by(id, year, month, day), color = id) # + 
      # geom_text(aes(label=id),hjust=-0.1, vjust=0)

# Looking at precipitation by month during 2006
qplot(month, monthly_ppt, data = dy_rg_data %>% 
            filter(year==2006) %>%
            group_by(id, year, month) %>%
            summarize(monthly_ppt=sum(daily_ppt)), 
      color = id, geom = 5, main = "Monthly total from daily data - 2006") #+
      geom_point(shape = 5, size = 1.5)

# An implementation of the `qplot` above using `ggplot`
ggplot(data = dy_rg_data %>% 
            filter(year==2006) %>%
            group_by(id, year, month) %>%
            summarize(monthly_ppt=sum(daily_ppt)),
       aes(x = month, y = monthly_ppt, color = id)) +
      geom_point(size=2, shape=3)
```

Make data frame of monthly totals and plot across all years
```{r summarise daily to monthly totals, echo=TRUE, eval=FALSE}
# Monthly precipitation (ppt) by year, month, and gauge id
monthly_ppt_id <- dy_rg_data %>%
      group_by(year, month, id) %>%# This grouping order causes reordering by year, month, then id
      summarise(monthly_ppt = sum(daily_ppt))
monthly_ppt_id
# Add date factor variable
monthly_ppt_id <- mutate(monthly_ppt_id, date = paste(year,"-",month, sep = ""))
# Convert date factor to `date` format for plotting
monthly_ppt_id$date <- as.Date(paste(monthly_ppt_id$date, "-01", sep=""))


# Aggregate to mean monthly precip across all gauges, so exclude id from the data frame `monthly_ppt_id`
monthly_ppt <- monthly_ppt_id %>%
      group_by(year, month, date) %>%
      summarise(avg_monthly_ppt = mean(monthly_ppt, na.rm=TRUE))
summary(monthly_ppt)
```

Plot monthly rainfall data
```{r plotting monthly data, echo=TRUE, eval=FALSE, fig.height=9, fig.width=6}
# Plot monthly rainfall grouped by plot ####
mp_id <- ggplot(data = monthly_ppt_id %>%
            filter(id == "cook" | id == "kunde" | id == "sawi"),
            #group_by(id),
       aes(x = date, y = monthly_ppt, color = id)) + 
      geom_point(size=2) +
      ylab("rainfall (inches)")

library(scales)
mp_id + facet_grid(id ~ ., scales = "fixed") + 
      theme_bw() + theme(legend.position = "none") +
      scale_x_date(breaks = date_breaks("6 months"), 
                   labels = date_format("%m/%y"),
                   minor_breaks = "1 month") +
      xlab("date (month/year)") + ggtitle("Total Monthly Rainfall 2004-2013")
ggsave("figures/mp_id.svg", width = 7, height = 5, scale = 1.5)
# mp + geom_boxplot()
# Adjust the way the date is scaled on the x-axis
#mp + scale_x_date(date)

# Plot monthly data averaged across plots
mp <- ggplot(data = monthly_ppt,
            #filter(id == "cook" | id == "kunde" | id == "sawi"),
            #group_by(id),
       aes(x = date, y = avg_monthly_ppt)) + 
      geom_point(size=2) +
      ylab("rainfall (inches)")

library(scales)
mp + geom_line() +
      theme_bw() + theme(legend.position = "none") +
      scale_x_date(breaks = date_breaks("1 year"), 
                   labels = date_format("%m/%y"),
                   minor_breaks = "1 month") +
      xlab("date (month/year)") + ggtitle("Average Monthly Rainfall 2004-2013")
ggsave("figures/avg_mp.svg", width = 7, height = 5, scale = 1.5)
```

```{r export plot to file, echo=TRUE, eval=TRUE}
# `ggsave` exports the current `ggplot` object
ggsave("figures/avg_mp.svg", width = 7, height = 5, scale = 1.5)
```


I also have data at an hourly resolution, but am not going to work with that for now
```{r hourly data, eval=FALSE, echo=TRUE}
hr_rg_data <- readRDS("hr_rg_data.rds")
summary(hr_rg_data)
qplot(id, hourly_ppt, data=hr_rg_data)
#Replace hourly_ppt values >= 1 inch
hr_rg_data$hourly_ppt[hr_rg_data$hourly_ppt>=1] <- NA

qplot(month, monthly_ppt, data = hr_rg_data %>%
      filter(year==2006) %>%
            group_by(id, year, month) %>%
            summarize(monthly_ppt=sum(hourly_ppt)), color = id,
      main="Monthly total from hourly data - 2006")
```

I want to group the daily data into data frames by month and year so that I can create and interpolation for precipitation for each unique month-year combination from each location. For example:
```{r group by year month, echo=TRUE}
ppt2004_01 <- dy_rg_data %>% #
      group_by(id, year, month) %>% 
      filter(year==2004, month==1) %>%
      summarise(monthly_ppt = sum(daily_ppt))
ppt2004_01
```

This is how I need each data frame to be structured, but I want to find a faster way to create the whole set of month-year combinations
```{r list of data frames split by month-year, echo=TRUE}
# Make a data frame of monthly totals for each year-month-location combination
monthly_ppt <- dy_rg_data %>%
      group_by(year, month, id) %>%
      summarise(monthly_ppt = sum(daily_ppt))
monthly_ppt

# Split that dataframe on the month and year to create a list of data frames with the total precipitation and location id for each month and year combo
df_list <- split(monthly_ppt, list(monthly_ppt$year, monthly_ppt$month))# 132 data frames
```

I wasn't sure what to do from here in trying to put each data frame into the global environment. I finally hit on the right search terms ("unlist data frame R") revealing this function in an answer on [Stack Overflow](http://stackoverflow.com/questions/17697239/r-unlist-a-list-of-dataframes):
```{r unlist data frames into environment, eval=FALSE}
list2env(df_list, .GlobalEnv))
```

Trying to figure out a `plyr` approach with `assign` so that I can name the data frames, but not having much luck.
```{r plyr unlist (fail), echo=FALSE, eval=FALSE}
ldply(df_list, function(i){
      assign(df_list[i], df_list[[i]])
})
```
Two commenters asked why you would even want to do this when you could just work on them as elements of the list. Can I match up the spatial data to the data frames in the list? Then can I also pass each data frame in that list to an interpolation function?

I am leaving the data frames in the list for now.

I was working on trying to subset the named list of dataframes using wildcards/regular expressions (`regexp`). I wanted to break them up by year due to relocation of some rain gauges, so this is necessary to make sure the data is joined to the correct coordinates. Rain gauges typically were not moved very far, so it may not matter much, but I am being thorough.

I figured out how to do it using regular expressions. 
```{r subset list using regular expression, echo=TRUE, eval=TRUE}
# These first two lines didn't get me anywhere
# l <- subset(df_list, df_list["*"]<=df_list["*2008"])
# Filter(function(x) length(x) > 3, l)



# I want to match on 200* EXCEPT 2009*, so the expression is matching on strings with anything following 200 except skipping the string if the next character is a 9.
df_list_names <- names(df_list)
l_names <- df_list_names[grep("200[^9]", df_list_names)]# Testing syntax
df_list_0408 <- df_list[grep("200[^9]", df_list_names)]# Making subsetted list

# I want to get the 2009-2011 data frames. The `|` operates as "or" in the expression, so I am matching on either of these three strings
l_names <- df_list_names[grep(grx, df_list_names)]# Testing syntax
df_list_0911 <- df_list[grep("2009|2010|2011", df_list_names)]# Making subsetted list

# And now the 2012-2014 data frames
l_names <- df_list_names[grep("2012|2013|2014", df_list_names)]
df_list_1214 <- df_list[grep("2012|2013|2014", df_list_names)]
```


A couple of rain gauges have been moved to new locations near their established areas over the years, so I have shapefiles corresponding the move of one or more gauge stations.
```{r list rain gague shapefiles}
list.files("shapefiles", pattern = "*.shx")
```
This shows that there are four shapefiles for various stretches of the study, 2003-2008, 2009-2011, 2012-2014, and then 2015 and beyond. The 2015 is the result of moving a rain gauge during our 2014 visits. I will not be using that file for the data I have in hand.



```{r breakdown years by shapefiles}
library(rgdal)# GDAL bindings for R; I believe this requires GDAL installed for your operating system
ogrListLayers("shapefiles")
rg_0308 <- readOGR(dsn="shapefiles", layer="RainGauges2003_2008")
str(rg_0308)
rg_0308@data$NAME
rg_0308@data$NAME <- tolower(rg_0308@data$NAME)
rg_0308@data$NAME[rg_0308@data$NAME=="macki"] <- "mackie"
rg_0308@data$NAME[rg_0308@data$NAME=="sdc"] <- "sec"
rg_0308@data$NAME[rg_0308@data$NAME=="sugar"] <- "sugarloaf"
unique(dy_rg_data$id)

month_rg_0308 <- dy_rg_data %>%
      group_by(id, year, month) %>% 
      filter(year<=2008) %>%
      summarise(monthly_ppt = sum(daily_ppt))
month_rg_0308$id <- as.factor(month_rg_0308$id)
summary(month_rg_0308)
```

```{r geostats}
library(sp)
library(raster)
library(rgdal)
elev <- raster("dem/sod15m.tif")
str(elev)
crs <- elev@crs
rg_0308 <- spTransform(rg_0308, CRS=crs)
str(rg_0308)
spplot(elev, scales=list(draw=T), sp.layout=list("sp.points", rg_0308))

rg_0308@data$elev <- extract(elev, rg_0308)
str(rg_0308)
#spplot(slope, scales=list(draw=T), sp.layout=list("sp.points", depth, pch="+"))
```

Joining monthly precipitation data to spatial points data frame
```{r joining data}
rg_0308@data <- inner_join(rg_0308@data, month_rg_0308, by = c("NAME" = "id"))
str(month_rg_0308)
str(rg_0308)
summary(rg_0308)
```

Plotting precipitation against elevation for a subset of the data
```{r plot elevation precip}
rg08 <- filter(rg_0308@data, year==2008)
qplot(rg_0308@data$elev, rg_0308@data$monthly_ppt)
qplot(elev, monthly_ppt, data = rg08, facets = .~ month, color = NAME, main = "2008 Rain")
qplot(elev, monthly_ppt, data = rg08 %>% filter(month==1), color = NAME, main = "January 2008 Rain") + geom_text(aes(label=NAME),hjust=-0.1, vjust=0)
```

Developing a linear modeling for kriging
```{r rk model jan 2008}
rg_0108 <- subset(rg_0308@data, year==2008 & month==1)
#coordinates(rg_0108) = ~NORTHING+EASTING
str(rg_0108)
rg_0308 <- readOGR(dsn="shapefiles", layer="RainGauges2003_2008")
rg_0308 <- spTransform(rg_0308, CRS=crs)
rg_0108@proj4string <- rg_0308@proj4string
rg_0108 <- spTransform(rg_0108, CRS=crs)

elev_ppt = overlay(as(elev, "SpatialGridDataFrame"), rg_0108)   # create grid-points overlay
   # copy the slope values
lm_rg_0108 <- lm(monthly_ppt ~ elev, rg_0108)
summary(lm_rg_0108)
```


```{r thin plate spline}
library(fields)
loc_matrix <- cbind(rg_0108$NORTHING,rg_0108$EASTING)
ppt <- c(rg_0108$monthly_ppt)
jan08tps <- Tps(loc_matrix, ppt)
summary(jan08tps)
plot(jan08tps)
surface(jan08tps)

look <- predict(jan08tps, lambda = 2.0)
look <- predict(jan08tps, df = 4)

tps1 <- Tps(loc_matrix, ppt, df = 4)
summary(tps1)
set.panel(2,2)
plot(tps1)
set.panel()

out_jan08 <- predictSurface(jan08tps)
image(out_jan08)

fit <- Tps(ozone$x, ozone$y)
set.panel(2,2)
plot(fit)

```
